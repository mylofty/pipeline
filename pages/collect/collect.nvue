<template>
  <div class="collect-container" @click="closeDropdown">
    <!-- é¡¶éƒ¨å·¥å…·æ  -->
    <div class="top-toolbar">
      <!-- å›¾å±‚ç®¡ç†ä¸‹æ‹‰æ¡† -->
      <div class="layer-selector">
        <div class="picker-display" @click.stop="toggleDropdown">
          <text class="picker-text">{{ getDisplayText() }}</text>
          <text class="arrow" :class="{ 'arrow-up': showDropdown }">â–¼</text>
        </div>
        <div class="dropdown" v-if="showDropdown" @click.stop>
          <div class="dropdown-item select-all-item" @click="selectAll">
            <text>å…¨é€‰</text>
          </div>
          <div class="dropdown-item select-all-item" @click="selectNone">
            <text>å…¨ä¸é€‰</text>
          </div>
          <div class="dropdown-divider"></div>
          <div class="dropdown-item" v-for="(item, index) in layerOptions" :key="index" @click="selectLayer(index)">
            <div class="checkbox-wrapper">
              <text class="checkbox" :class="{ checked: selectedLayers.includes(index) }">{{
                selectedLayers.includes(index) ? 'âœ“' : '' }}</text>
              <text class="layer-name">{{ item }}</text>
            </div>
          </div>
        </div>
      </div>

    <!-- æ¢ç‚¹å·æœç´¢æ¡† -->
    <div class="search-container">
        <input type="text" placeholder="æœç´¢ç®¡ç‚¹ç‰©æ¢ç‚¹å·..." v-model="searchPointNo" @input="onSearchInput" @confirm="searchPoint"
            class="search-input" confirm-type="search" @click.stop />
        <div class="search-btn" @click="searchPoint">
            <text>ğŸ”</text>
        </div>
    </div>
	

    </div>

    <!-- åœ°å›¾å®¹å™¨ -->
    <div class="map-wrapper">
      <map id="amap" class="amap" :longitude="mapCenter.longitude" :latitude="mapCenter.latitude" :scale="mapScale"
        :markers="markers" :polyline="polylines" :polygons="polygons" @tap="onMapTap" @click="onMapTap"
        @markertap="onMarkerTap" @poitap="onPoiTap" @regionchange="onRegionChange" @error="onMapError" @callouttap="onCalloutTap"
        @controltap="onControlTap" show-location enable-3D enable-overlooking enable-zoom enable-scroll enable-rotate
        :enable-satellite="mapType === 'satellite'">
      </map>

      <!-- å®šä½æŒ‰é’® -->
      <div class="location-btn" @tap="getCurrentLocation">
        <text class="location-text">å®šä½</text>
		<!-- ğŸ“ -->
      </div>

      <!-- åœ°å›¾ä¸­å¿ƒåå­—å‡†æ˜Ÿ -->
      <div class="map-crosshair" v-if="currentTool">
        <div class="crosshair-horizontal"></div>
        <div class="crosshair-vertical"></div>
      </div>

      <!-- å³ä¾§å·¥å…·æ ç»„ä»¶ -->
      <MapToolbar 
        :currentTool="currentTool"
        :mapType="mapType"
        @toggle-map-type="toggleMapType"
        @select-tool="selectTool"
      />
    </div>

    <!-- æµ‹é‡ç»“æœæ˜¾ç¤º -->
    <div class="measure-result" v-if="measureResult.show">
      <div class="result-content">
        <text class="result-title">æµ‹é‡ç»“æœ</text>
        <text class="result-value">{{ measureResult.text }}</text>
        <div class="result-actions">
          <div class="clear-btn" @click="clearMeasure">
            <text>æ¸…é™¤</text>
          </div>
          <div class="close-btn" @click="closeMeasureResult">
            <text>å…³é—­</text>
          </div>
        </div>
      </div>
    </div>
  </div>
</template>

<script>
import { ref, reactive, onMounted, onUnmounted, computed } from 'vue'
import MapToolbar from './components/MapToolbar.nvue'

export default {
  components: {
    MapToolbar
  },
  setup() {
    // å“åº”å¼æ•°æ®
    const searchPointNo = ref('')
    const currentTool = ref('')
    const mapType = ref('vector') // vector æˆ– satellite
    const mapScale = ref(16)
    const currentLayerIndex = ref(0)
    const showDropdown = ref(false)
    const selectedLayers = ref([0]) // é»˜è®¤é€‰ä¸­ç¬¬ä¸€ä¸ªå›¾å±‚
    const materialIndex = ref(0)
    const lineTypeIndex = ref(0)
    const lineMaterialIndex = ref(0)

    // ç®¡çº¿ç›¸å…³çŠ¶æ€
    const pipelineMode = ref(false)
    const selectedPoints = ref([])

    // å›¾å±‚é€‰é¡¹
    const layerOptions = ref([
      'ç»™æ°´ç®¡ç½‘',
      'æ’æ°´ç®¡ç½‘',
      'ç‡ƒæ°”ç®¡ç½‘',
      'çƒ­åŠ›ç®¡ç½‘',
      'ç”µåŠ›ç®¡ç½‘',
      'é€šä¿¡ç®¡ç½‘'
    ])


    // åœ°å›¾ä¸­å¿ƒç‚¹
    const mapCenter = reactive({
      longitude: 113.49815398004169,
      latitude: 23.15523741570118
    })

    // å¼¹çª—æ˜¾ç¤ºçŠ¶æ€
    const showPointModal = ref(false)
    const showLineModal = ref(false)
    const showPipePointModal = ref(false)

    // æµ‹é‡ç»“æœ
    const measureResult = reactive({
      show: false,
      text: '',
      type: '' // distance æˆ– area
    })

    // é€‰ä¸­çš„ç®¡ç‚¹ä¿¡æ¯
    const selectedPipePoint = reactive({
      id: '',
      type: '',
      diameter: '',
      material: '',
      depth: '',
      status: ''
    })

    // åœ°å›¾æ•°æ®
    const markers = ref([])
    const polylines = ref([])
    const polygons = ref([])

    // ä¸´æ—¶æ•°æ®
    const tempPoints = ref([]) // ç”¨äºè¿çº¿æ—¶çš„ä¸´æ—¶ç‚¹
    const measurePoints = ref([]) // æµ‹é‡æ—¶çš„ç‚¹

    // æ–¹æ³•å®ç°
    const toggleDropdown = () => {
      showDropdown.value = !showDropdown.value
    }

    const selectLayer = (index) => {
      if (selectedLayers.value.includes(index)) {
        selectedLayers.value = selectedLayers.value.filter(i => i !== index)
      } else {
        selectedLayers.value.push(index)
      }

      // æ›´æ–°å½“å‰æ˜¾ç¤ºçš„å›¾å±‚
      if (selectedLayers.value.length > 0) {
        currentLayerIndex.value = selectedLayers.value[0]
      }

      updateLayerDisplay()
    }

    const selectAll = () => {
      selectedLayers.value = layerOptions.value.map((_, index) => index)
      currentLayerIndex.value = 0
      updateLayerDisplay()
      uni.showToast({
        title: 'å·²å…¨é€‰æ‰€æœ‰å›¾å±‚',
        icon: 'none'
      })
    }

    const selectNone = () => {
      selectedLayers.value = []
      updateLayerDisplay()
      uni.showToast({
        title: 'å·²å–æ¶ˆé€‰æ‹©æ‰€æœ‰å›¾å±‚',
        icon: 'none'
      })
    }

    const updateLayerDisplay = () => {
      if (selectedLayers.value.length === 0) {
        // æ²¡æœ‰é€‰ä¸­ä»»ä½•å›¾å±‚æ—¶çš„å¤„ç†
      } else if (selectedLayers.value.length === 1) {
        currentLayerIndex.value = selectedLayers.value[0]
      } else {
        // å¤šé€‰æ—¶æ˜¾ç¤ºæ•°é‡
        currentLayerIndex.value = selectedLayers.value[0]
      }
    }

    const getDisplayText = () => {
      if (selectedLayers.value.length === 0) {
        return 'è¯·é€‰æ‹©å›¾å±‚'
      } else if (selectedLayers.value.length === 1) {
        return layerOptions.value[selectedLayers.value[0]]
      } else if (selectedLayers.value.length === layerOptions.value.length) {
        return 'å…¨éƒ¨å›¾å±‚'
      } else {
        return `å·²é€‰æ‹©${selectedLayers.value.length}ä¸ªå›¾å±‚`
      }
    }

    const closeDropdown = () => {
      showDropdown.value = false
    }

    const onSearchInput = (e) => {
      searchPointNo.value = e.detail.value
    }

    const searchPoint = () => {
      console.log('æœç´¢è§¦å‘ï¼Œå½“å‰è¾“å…¥å€¼:', searchPointNo.value)
      
      if (!searchPointNo.value || !searchPointNo.value.trim()) {
        uni.showToast({
          title: 'è¯·è¾“å…¥æ¢ç‚¹å·',
          icon: 'none'
        })
        return
      }

      // æœç´¢é€»è¾‘
      const foundMarker = markers.value.find(marker =>
        marker.title && marker.title.includes(searchPointNo.value.trim())
      )

      if (foundMarker) {
        mapCenter.longitude = foundMarker.longitude
        mapCenter.latitude = foundMarker.latitude
        mapScale.value = 18
        uni.showToast({
          title: 'å·²å®šä½åˆ°ç›®æ ‡ç‚¹',
          icon: 'success'
        })
      } else {
        uni.showToast({
          title: 'æœªæ‰¾åˆ°è¯¥æ¢ç‚¹å·',
          icon: 'none'
        })
      }
    }

    const toggleMapType = () => {
      mapType.value = mapType.value === 'vector' ? 'satellite' : 'vector'
      uni.showToast({
        title: `å·²åˆ‡æ¢åˆ°${mapType.value === 'satellite' ? 'å½±åƒ' : 'çŸ¢é‡'}åœ°å›¾`,
        icon: 'none'
      })
    }

    const selectTool = (tool) => {
      // å¦‚æœç‚¹å‡»çš„æ˜¯å½“å‰å·¥å…·ï¼Œåˆ™å–æ¶ˆé€‰æ‹©
      if (currentTool.value === tool) {
        currentTool.value = ''
        pipelineMode.value = false
        // æ¸…é™¤ç®¡çº¿é€‰æ‹©çŠ¶æ€
        if (tool === 'line') {
          selectedPoints.value.forEach(point => {
            highlightMarker(point.id, false)
          })
          selectedPoints.value = []
        }
      } else {
        currentTool.value = tool
        
        // å¦‚æœé€‰æ‹©ç®¡çº¿å·¥å…·ï¼Œå¯åŠ¨ç®¡çº¿æ¨¡å¼
        if (tool === 'line') {
          pipelineMode.value = true
          selectedPoints.value = []
        } else {
          pipelineMode.value = false
        }
      }

      // æ¸…é™¤ä¸´æ—¶æ•°æ®
      tempPoints.value = []
      measurePoints.value = []

      const toolNames = {
        point: 'ç®¡ç‚¹å·¥å…·',
        line: 'ç®¡çº¿å·¥å…·',
        virtual: 'è™šæ‹Ÿçº¿å·¥å…·',
        shared: 'å…±ç®¡å·¥å…·',
        insert: 'æ’å…¥å·¥å…·',
        collect: 'æ”¶ç‚¹å·¥å…·',
        edit: 'ç¼–è¾‘å·¥å…·',
        measure: 'æµ‹é‡å·¥å…·',
        flow: 'æµå‘å·¥å…·',
        move: 'ç§»åŠ¨å·¥å…·',
        delete: 'åˆ é™¤å·¥å…·'
      }

      if (currentTool.value) {
        if (tool === 'line') {
          uni.showToast({
            title: 'ç®¡çº¿æ¨¡å¼å·²å¯åŠ¨ï¼Œè¯·ä¾æ¬¡ç‚¹å‡»ä¸¤ä¸ªå·²æœ‰çš„ç®¡ç‚¹',
            icon: 'none'
          })
        } else {
          uni.showToast({
            title: `å·²é€‰æ‹©${toolNames[tool]}ï¼Œè¯·åœ¨åœ°å›¾ä¸Šé€‰æ‹©ä½ç½®`,
            icon: 'none'
          })
        }
      }
    }

    // æå–å…¬å…±çš„åœ°å›¾ç‚¹å‡»å¤„ç†é€»è¾‘
    const handleTapForCreation = (longitude, latitude) => {
      uni.showModal({
        title: 'åˆ›å»ºç¡®è®¤',
        content: `å°†åœ¨ç‚¹å‡»ä½ç½®åˆ›å»º${getToolName(currentTool.value)}ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`,
        success: (res) => {
          if (res.confirm) {
            console.log('ä½¿ç”¨åæ ‡:', longitude, latitude);

            switch (currentTool.value) {
              case 'point':
                createPoint(longitude, latitude);
                break;
              case 'line':
                handleLineCreation(longitude, latitude);
                break;
              case 'virtual':
                createVirtualLine(longitude, latitude);
                break;
              case 'measure':
                handleMeasure(longitude, latitude);
                break;
              case 'insert':
                insertPoint(longitude, latitude);
                break;
              default:
                break;
            }
          }
        }
      });
    };

    //åˆ›å»ºå·¥å…·
    const onMapTap = (e) => {
      console.log('onMapTap', e);
      
      if (!currentTool.value) {
        uni.showToast({
          title: 'è¯·å…ˆé€‰æ‹©åˆ›å»ºå·¥å…·',
          icon: 'none'
        });
        return;
      }

      // å¦‚æœæ˜¯ç®¡çº¿å·¥å…·ï¼Œç›´æ¥æç¤ºç”¨æˆ·ç‚¹å‡»ç®¡ç‚¹ï¼Œä¸è¦è°ƒç”¨handleTapForCreation
      if (currentTool.value === 'line') {
        uni.showToast({
          title: 'è¯·ç‚¹å‡»å·²æœ‰çš„ç®¡ç‚¹ï¼Œä¸è¦ç‚¹å‡»ç©ºç™½åŒºåŸŸ',
          icon: 'none'
        });
        return;
      }

      // è·å–ç‚¹å‡»ä½ç½®çš„åæ ‡
      let clickLongitude, clickLatitude;
      
      if (e.detail && e.detail.longitude !== undefined && e.detail.latitude !== undefined) {
        // ä»äº‹ä»¶è¯¦æƒ…ä¸­è·å–ç‚¹å‡»åæ ‡
        clickLongitude = e.detail.longitude;
        clickLatitude = e.detail.latitude;
        console.log('è·å–åˆ°ç‚¹å‡»åæ ‡:', clickLongitude, clickLatitude);
      } else {
        // å¦‚æœæ— æ³•è·å–ç‚¹å‡»åæ ‡ï¼Œä½¿ç”¨åœ°å›¾ä¸­å¿ƒç‚¹ä½œä¸ºå¤‡é€‰
        clickLongitude = mapCenter.longitude;
        clickLatitude = mapCenter.latitude;
        console.log('ä½¿ç”¨åœ°å›¾ä¸­å¿ƒç‚¹åæ ‡ä½œä¸ºå¤‡é€‰:', clickLongitude, clickLatitude);
      }

      handleTapForCreation(clickLongitude, clickLatitude);
    }

    // è·å–å·¥å…·åç§°
    const getToolName = (tool) => {
      const toolNames = {
        point: 'ç®¡ç‚¹',
        line: 'ç®¡çº¿',
        virtual: 'è™šæ‹Ÿçº¿',
        shared: 'å…±ç®¡',
        insert: 'æ’å…¥ç‚¹',
        collect: 'æ”¶ç‚¹',
        edit: 'ç¼–è¾‘',
        measure: 'æµ‹é‡',
        flow: 'æµå‘',
        move: 'ç§»åŠ¨',
        delete: 'åˆ é™¤'
      };
      return toolNames[tool] || 'å…ƒç´ ';
    }

    // POIç‚¹å‡»äº‹ä»¶å¤„ç†ï¼ˆå¤„ç†åœ°å›¾ä¸Šçš„å…´è¶£ç‚¹ï¼Œå¦‚"ä¸œé—¨"ã€"å¹¼å„¿å›­"ç­‰ï¼‰
    const onPoiTap = (e) => {
      console.log('POIç‚¹å‡»äº‹ä»¶:', e);
      
      if (!currentTool.value) {
        uni.showToast({
          title: 'è¯·å…ˆé€‰æ‹©åˆ›å»ºå·¥å…·',
          icon: 'none'
        });
        return;
      }

      // è·å–POIç‚¹å‡»ä½ç½®çš„åæ ‡
      let clickLongitude, clickLatitude;
      
      if (e.detail && e.detail.longitude !== undefined && e.detail.latitude !== undefined) {
        clickLongitude = e.detail.longitude;
        clickLatitude = e.detail.latitude;
        console.log('ä»POIäº‹ä»¶è·å–åæ ‡:', clickLongitude, clickLatitude);
      } else {
        // å¦‚æœæ— æ³•è·å–åæ ‡ï¼Œä½¿ç”¨åœ°å›¾ä¸­å¿ƒç‚¹
        clickLongitude = mapCenter.longitude;
        clickLatitude = mapCenter.latitude;
        console.log('POIäº‹ä»¶æ— åæ ‡ï¼Œä½¿ç”¨åœ°å›¾ä¸­å¿ƒç‚¹:', clickLongitude, clickLatitude);
      }

      // æç¤ºç”¨æˆ·ç¡®è®¤åˆ›å»ºä½ç½®
      uni.showModal({
        title: 'åˆ›å»ºç¡®è®¤',
        content: `å°†åœ¨${e.detail?.name || 'POIç‚¹'}ä½ç½®åˆ›å»º${getToolName(currentTool.value)}ï¼Œæ˜¯å¦ç»§ç»­ï¼Ÿ`,
        success: (res) => {
          if (res.confirm) {
            console.log('ç¡®è®¤åœ¨POIä½ç½®åˆ›å»ºï¼Œåæ ‡:', clickLongitude, clickLatitude);

            switch (currentTool.value) {
              case 'point':
                createPoint(clickLongitude, clickLatitude);
                break;
              case 'virtual':
                createVirtualLine(clickLongitude, clickLatitude);
                break;
              case 'measure':
                handleMeasure(clickLongitude, clickLatitude);
                break;
              case 'insert':
                insertPoint(clickLongitude, clickLatitude);
                break;
              default:
                break;
            }
          }
        }
      });
    }

    // æ·»åŠ å…¶ä»–äº‹ä»¶å¤„ç†
    const onCalloutTap = (e) => {
      console.log('calloutç‚¹å‡»:', e);
    }

    // ç›‘å¬åœ°å›¾æ§ä»¶çš„ç‚¹å‡»äº‹ä»¶â€‹â€‹
    const onControlTap = (e) => {
      console.log('controlç‚¹å‡»:', e);
    }

    // æ‰“ç‚¹ - è·³è½¬åˆ°ç®¡ç‚¹ä¿¡æ¯é¡µé¢
    const createPoint = (longitude, latitude) => {
      // è·³è½¬åˆ°ç®¡ç‚¹ä¿¡æ¯é¡µé¢ï¼Œä¼ é€’åæ ‡å‚æ•°
      uni.navigateTo({
        url: `/pages/collect/pipe-info?longitude=${longitude}&latitude=${latitude}`
      });
      
      // æ¸…é™¤å·¥å…·é€‰æ‹©
      // currentTool.value = ''
    }

    // ç®¡çº¿å·¥å…· - å¤„ç†åœ°å›¾ç©ºç™½åŒºåŸŸçš„ç‚¹å‡»ï¼ˆæç¤ºç”¨æˆ·ç‚¹å‡»ç®¡ç‚¹ï¼‰
    const handleLineCreation = (longitude, latitude) => {
      uni.showToast({
        title: 'è¯·ç‚¹å‡»å·²æœ‰çš„ç®¡ç‚¹ï¼Œä¸è¦ç‚¹å‡»ç©ºç™½åŒºåŸŸ',
        icon: 'none'
      })
    }



    // é«˜äº®æ ‡è®°ç‚¹
    const highlightMarker = (markerId, highlight) => {
      const markerIndex = markers.value.findIndex(m => m.id === markerId)
      if (markerIndex > -1) {
        markers.value[markerIndex].iconPath = highlight 
          ? '/static/icons/pipe-point.png' 
          : '/static/icons/point.png'
        // æ”¹å˜æ ‡è®°ç‚¹çš„å¤§å°æ¥è¡¨ç¤ºé€‰ä¸­çŠ¶æ€
        markers.value[markerIndex].width = highlight ? 40 : 30
        markers.value[markerIndex].height = highlight ? 40 : 30
      }
    }

    // åˆ›å»ºè™šæ‹Ÿçº¿é€»è¾‘
    const createVirtualLine = (longitude, latitude) => {
      console.log("createVirtualLine", longitude, latitude)
      const virtualLine = {
        points: [
          { longitude, latitude },
          { longitude: longitude + 0.001, latitude: latitude + 0.001 }
        ],
        color: '#FF9800',
        width: 2,
        dottedLine: true
      }
      polylines.value.push(virtualLine)

      uni.showToast({
        title: 'è™šæ‹Ÿçº¿åˆ›å»ºæˆåŠŸ',
        icon: 'success'
      })
    }

    // æµ‹é‡å·¥å…·
    const handleMeasure = (longitude, latitude) => {
      measurePoints.value.push({ longitude, latitude })

      if (measurePoints.value.length >= 2) {
        let totalDistance = 0
        for (let i = 1; i < measurePoints.value.length; i++) {
          const distance = calculateDistance(
            measurePoints.value[i - 1].latitude,
            measurePoints.value[i - 1].longitude,
            measurePoints.value[i].latitude,
            measurePoints.value[i].longitude
          )
          totalDistance += distance
        }

        measureResult.text = `æ€»é•¿åº¦: ${totalDistance.toFixed(2)}ç±³`
        measureResult.type = 'distance'
        measureResult.show = true
      }
    }

    //æ’å…¥å·¥å…·
    const insertPoint = (longitude, latitude) => {
      // åœ¨æœ€è¿‘çš„ç®¡çº¿ä¸Šæ’å…¥ç‚¹
      uni.showToast({
        title: 'æ’å…¥ç‚¹åŠŸèƒ½å¼€å‘ä¸­',
        icon: 'none'
      })
    }

    // è®¡ç®—åœ°çƒä¸Šä¸¤ç‚¹ä¹‹é—´çš„å¤§åœ†è·ç¦»ï¼ˆä¸¤ç‚¹ä¹‹é—´çš„æœ€çŸ­è·ç¦»ï¼‰
    const calculateDistance = (lat1, lon1, lat2, lon2) => {
      const R = 6371000 // åœ°çƒåŠå¾„ï¼ˆç±³ï¼‰
      const dLat = (lat2 - lat1) * Math.PI / 180
      const dLon = (lon2 - lon1) * Math.PI / 180
      const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
        Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
        Math.sin(dLon / 2) * Math.sin(dLon / 2)
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a))
      return R * c
    }

    // è®¡ç®—ç®­å¤´æ—‹è½¬è§’åº¦
    const calculateArrowRotation = (lat1, lon1, lat2, lon2) => {
      const dLon = (lon2 - lon1) * Math.PI / 180
      const lat1Rad = lat1 * Math.PI / 180
      const lat2Rad = lat2 * Math.PI / 180
      
      const y = Math.sin(dLon) * Math.cos(lat2Rad)
      const x = Math.cos(lat1Rad) * Math.sin(lat2Rad) - Math.sin(lat1Rad) * Math.cos(lat2Rad) * Math.cos(dLon)
      
      const bearing = Math.atan2(y, x) * 180 / Math.PI
      return (bearing + 360) % 360 // ç¡®ä¿è§’åº¦ä¸ºæ­£å€¼
    }

    //è·³è½¬åˆ°ç®¡ç‚¹ä¿¡æ¯é¡µé¢ï¼ˆå¦‚æœéœ€è¦çš„è¯ï¼‰
    const openPipeInfo = () => {
      uni.showToast({
        title: 'è¯·å…ˆé€‰æ‹©ç®¡ç‚¹å·¥å…·ï¼Œç„¶ååœ¨åœ°å›¾ä¸Šé€‰æ‹©ä½ç½®',
        icon: 'none'
      });
    }

    // å®ç°åœ°å›¾äº¤äº’åŠŸèƒ½
    const onMarkerTap = (e) => {
      console.log('=== onMarkerTapäº‹ä»¶è°ƒè¯• ===');
      console.log('å®Œæ•´äº‹ä»¶å¯¹è±¡:', JSON.stringify(e, null, 2));

      if (!e.detail || !e.detail.markerId) {
        console.log('âŒ äº‹ä»¶è¯¦æƒ…æˆ–markerIdä¸ºç©º');
        return
      }

      const markerId = e.detail.markerId
      console.log('ğŸ“ ç‚¹å‡»çš„markerId:', markerId, '(ç±»å‹:', typeof markerId, ')');
      console.log('ğŸ“‹ å½“å‰æ‰€æœ‰markers:');
      markers.value.forEach((m, index) => {
        console.log(`  ${index}: id="${m.id}" (ç±»å‹:${typeof m.id}), title="${m.title}"`);
      });
      
      // ç®€åŒ–æŸ¥æ‰¾é€»è¾‘ï¼Œä¸“æ³¨äºæ•°å­—IDåŒ¹é…
      let marker = markers.value.find(m => m.id === markerId || m.markerId === markerId)
      console.log('ğŸ” ç›´æ¥åŒ¹é…ç»“æœ:', marker ? 'æ‰¾åˆ°' : 'æœªæ‰¾åˆ°');
      
      console.log('âœ… æœ€ç»ˆæ‰¾åˆ°çš„marker:', marker);

      // å¦‚æœå½“å‰å·¥å…·æ˜¯"ç®¡çº¿"ï¼Œå¤„ç†ç®¡çº¿æ¨¡å¼ä¸‹çš„ç®¡ç‚¹é€‰æ‹©
      if (currentTool.value === 'line') {
        if (!marker) {
          uni.showToast({
            title: 'æœªæ‰¾åˆ°ç®¡ç‚¹ä¿¡æ¯ï¼Œè¯·ç¡®ä¿ç‚¹å‡»çš„æ˜¯å·²æœ‰ç®¡ç‚¹',
            icon: 'none'
          })
          return
        }

        // æ£€æŸ¥æ˜¯å¦å·²ç»é€‰æ‹©è¿‡è¿™ä¸ªç‚¹
        if (selectedPoints.value.find(p => p.id === marker.id)) {
          uni.showToast({
            title: 'è¯¥ç®¡ç‚¹å·²è¢«é€‰æ‹©',
            icon: 'none'
          })
          return
        }

        selectedPoints.value.push(marker)

        if (selectedPoints.value.length === 1) {
          // é«˜äº®ç¬¬ä¸€ä¸ªé€‰ä¸­çš„ç‚¹
          highlightMarker(marker.id, true)
          uni.showToast({
            title: `å·²é€‰æ‹©èµ·ç‚¹ï¼š${marker.title || marker.id}ï¼Œè¯·é€‰æ‹©ç»ˆç‚¹`,
            icon: 'none'
          })
        } else if (selectedPoints.value.length === 2) {
          // é«˜äº®ç¬¬äºŒä¸ªé€‰ä¸­çš„ç‚¹
          highlightMarker(marker.id, true)
          
          // è·³è½¬åˆ°ç®¡çº¿é…ç½®é¡µé¢
          navigateToPipelineConfig()
        }
        return; // é˜»æ­¢åç»­çš„æ ‡è®°ç‚¹å¤„ç†é€»è¾‘
      }

      // å¦‚æœå½“å‰å·¥å…·æ˜¯â€œç®¡ç‚¹â€ï¼Œåˆ™å°†æ ‡è®°ç‚¹ç‚¹å‡»è§†ä¸ºåœ°å›¾ç‚¹å‡»ï¼Œç”¨äºåˆ›å»ºç®¡ç‚¹
      if (currentTool.value === 'point') {
        // ä»markerå¯¹è±¡è·å–åæ ‡ï¼Œè¿™æ˜¯æˆ‘ä»¬åˆ›å»ºmarkeræ—¶å­˜å‚¨çš„åæ ‡
        if (marker && marker.longitude !== undefined && marker.latitude !== undefined) {
          console.log('ä»markerå¯¹è±¡è·å–åæ ‡:', marker.longitude, marker.latitude);
          handleTapForCreation(marker.longitude, marker.latitude);
        } else {
          // å¦‚æœmarkeræ²¡æœ‰åæ ‡ä¿¡æ¯ï¼Œä½¿ç”¨åœ°å›¾ä¸­å¿ƒç‚¹
          console.log('markeræ²¡æœ‰åæ ‡ä¿¡æ¯ï¼Œä½¿ç”¨åœ°å›¾ä¸­å¿ƒç‚¹:', mapCenter.longitude, mapCenter.latitude);
          handleTapForCreation(mapCenter.longitude, mapCenter.latitude);
        }
        return; // é˜»æ­¢åç»­çš„æ ‡è®°ç‚¹å¤„ç†é€»è¾‘
      }

      if (currentTool.value === 'edit' && marker) {
        // ç¼–è¾‘ç®¡ç‚¹
        Object.assign(pointForm, marker.data || {})
        showPointModal.value = true
      } else if (currentTool.value === 'delete' && marker) {
        // åˆ é™¤ç®¡ç‚¹
        uni.showModal({
          title: 'ç¡®è®¤åˆ é™¤',
          content: 'ç¡®å®šè¦åˆ é™¤è¿™ä¸ªç®¡ç‚¹å—ï¼Ÿ',
          success: (res) => {
            if (res.confirm) {
              const index = markers.value.findIndex(m => m.id === markerId)
              if (index > -1) {
                markers.value.splice(index, 1)
                uni.showToast({
                  title: 'åˆ é™¤æˆåŠŸ',
                  icon: 'success'
                })
              }
            }
          }
        })
      } else if (!currentTool.value && marker) {
        // æ²¡æœ‰é€‰æ‹©å·¥å…·æ—¶ï¼Œæ˜¾ç¤ºç®¡ç‚¹ä¿¡æ¯
        const data = marker.data || {}
        Object.assign(selectedPipePoint, {
          id: data.pointNo || marker.title || 'æœªçŸ¥',
          type: 'ç®¡ç‚¹',
          diameter: data.diameter || 'æœªçŸ¥',
          material: data.material || 'æœªçŸ¥',
          depth: data.depth || 'æœªçŸ¥',
          status: 'æ­£å¸¸'
        })
        showPipePointModal.value = true
      }
    }

    // ç›‘å¬åœ°å›¾çš„ç§»åŠ¨ã€ç¼©æ”¾ç­‰æ“ä½œâ€‹â€‹
    const onRegionChange = (e) => {
      // ä»…åœ¨å˜åŒ–ç»“æŸæ—¶ï¼ˆe.type === 'end'ï¼‰æ›´æ–°ä¸­å¿ƒç‚¹åæ ‡â€‹
      if (e.type === 'end' && e.detail && e.detail.centerLocation) {
        mapCenter.longitude = e.detail.centerLocation.longitude
        mapCenter.latitude = e.detail.centerLocation.latitude
      }
    }

    // å¼¹çª—ç›¸å…³æ–¹æ³•
    const closePointModal = () => {
      showPointModal.value = false
      Object.assign(pointForm, {
        pointNo: '',
        diameter: '',
        material: '',
        depth: '',
        remark: '',
        longitude: 0,
        latitude: 0
      })
    }

    // è·³è½¬åˆ°ç®¡çº¿é…ç½®é¡µé¢
    const navigateToPipelineConfig = () => {
      console.log('å‡†å¤‡è·³è½¬åˆ°ç®¡çº¿é…ç½®é¡µé¢');
      console.log('é€‰ä¸­çš„ç‚¹ä½:', selectedPoints.value);
      
      if (selectedPoints.value.length !== 2) {
        uni.showToast({
          title: 'è¯·å…ˆé€‰æ‹©ä¸¤ä¸ªç‚¹ä½',
          icon: 'none'
        });
        return;
      }
      
      const startPointData = encodeURIComponent(JSON.stringify(selectedPoints.value[0]))
      const endPointData = encodeURIComponent(JSON.stringify(selectedPoints.value[1]))
      
      console.log('ä¼ é€’çš„èµ·ç‚¹æ•°æ®:', selectedPoints.value[0]);
      console.log('ä¼ é€’çš„ç»ˆç‚¹æ•°æ®:', selectedPoints.value[1]);
      
      uni.navigateTo({
        url: `/pages/collect/pipeline-config?startPoint=${startPointData}&endPoint=${endPointData}`
      })
    }

    // æ·»åŠ ç®¡çº¿åˆ°åœ°å›¾ï¼ˆä»é…ç½®é¡µé¢è¿”å›æ—¶è°ƒç”¨ï¼‰
    const addPipeline = (pipelineData) => {
      console.log('æ¥æ”¶åˆ°ç®¡çº¿æ•°æ®:', pipelineData)
      
      if (!pipelineData.startPointData || !pipelineData.endPointData) {
        console.error('ç¼ºå°‘ç‚¹ä½æ•°æ®:', pipelineData);
        uni.showToast({
          title: 'æ•°æ®é”™è¯¯ï¼Œæ— æ³•åˆ›å»ºç®¡çº¿',
          icon: 'none'
        });
        return;
      }
      
      // åˆ›å»ºçº¢è‰²ç®¡çº¿ï¼ˆä¸å¸¦ç®­å¤´å±æ€§ï¼Œå› ä¸ºuni-appä¸æ”¯æŒï¼‰
      const newPipeline = {
        points: [
          {
            longitude: pipelineData.startPointData.longitude,
            latitude: pipelineData.startPointData.latitude
          },
          {
            longitude: pipelineData.endPointData.longitude,
            latitude: pipelineData.endPointData.latitude
          }
        ],
        color: '#FF0000', // çº¢è‰²
        width: 2,
        dottedLine: false, // å®çº¿
        data: pipelineData
      }

      console.log('åˆ›å»ºçš„ç®¡çº¿å¯¹è±¡:', newPipeline);
      
      // æ·»åŠ åˆ°åœ°å›¾
      polylines.value.push(newPipeline)
      
      // è®¡ç®—ç®­å¤´ä½ç½®ï¼ˆåœ¨ç»ˆç‚¹å‰ä¸€å°æ®µè·ç¦»ï¼‰
      const startLat = pipelineData.startPointData.latitude
      const startLng = pipelineData.startPointData.longitude
      const endLat = pipelineData.endPointData.latitude
      const endLng = pipelineData.endPointData.longitude
      
      // è®¡ç®—æ–¹å‘å‘é‡å¹¶åœ¨ç»ˆç‚¹å‰æ”¾ç½®ç®­å¤´
      const distance = 0.0001 // ç®­å¤´è·ç¦»ç»ˆç‚¹çš„è·ç¦»
      const bearing = calculateArrowRotation(startLat, startLng, endLat, endLng)
      const arrowLat = endLat - distance * Math.cos(bearing * Math.PI / 180)
      const arrowLng = endLng - distance * Math.sin(bearing * Math.PI / 180)
      
      // åˆ›å»ºç®­å¤´æ ‡è®°ï¼ˆçœ‹èµ·æ¥åƒçº¿æ¡çš„ä¸€éƒ¨åˆ†ï¼‰
      const arrowMarker = {
        id: `arrow_${Date.now()}`,
        longitude: arrowLng,
        latitude: arrowLat,
        iconPath: '/static/icons/arrow.png',
        width: 16,
        height: 16,
        rotate: bearing,
        anchor: {
          x: 0.5,
          y: 0.5
        }
      }
      
      markers.value.push(arrowMarker)
      
      console.log('å½“å‰æ‰€æœ‰ç®¡çº¿:', polylines.value);
      console.log('æ·»åŠ äº†ç»ˆç‚¹æ ‡è®°');

      // å¼ºåˆ¶åˆ·æ–°åœ°å›¾æ•°æ®
      polylines.value = [...polylines.value]
      markers.value = [...markers.value]

      // æ¸…é™¤é€‰ä¸­çŠ¶æ€
      selectedPoints.value.forEach(point => {
        highlightMarker(point.id, false)
      })
      selectedPoints.value = []
      currentTool.value = ''

      uni.showToast({
        title: 'ç®¡çº¿åˆ›å»ºæˆåŠŸ',
        icon: 'success'
      })
    }

    // æ¸…é™¤æµ‹é‡ç»“æœ
    const clearMeasure = () => {
      measurePoints.value = []
      measureResult.show = false
    }

    //å…³é—­æµ‹é‡ç»“æœ
    const closeMeasureResult = () => {
      measureResult.show = false
    }

    // åœ°å›¾é”™è¯¯å¤„ç†
    const onMapError = (e) => {
      console.error('åœ°å›¾åŠ è½½é”™è¯¯:', e)
      uni.showToast({
        title: 'åœ°å›¾åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè¿æ¥',
        icon: 'none',
        duration: 3000
      })
    }

    // æµ‹è¯•polylineåŠŸèƒ½
    const testPolyline = () => {
      const testLine = {
        points: [
          { longitude: 113.49815398004169, latitude: 23.15523741570118 },
          { longitude: 113.49925636792796, latitude: 23.153686206045506 }
        ],
        // color: '#FF0000',
        width: 8,
        dottedLine: false,
        // arrowIconPath: '/static/icons/arrow.png', // ç®­å¤´å›¾æ ‡è·¯å¾„
		arrowLine: true,
      }
      polylines.value.push(testLine)
      console.log('æ·»åŠ æµ‹è¯•çº¿æ¡:', testLine)
      uni.showToast({
        title: 'æµ‹è¯•çº¿æ¡å·²æ·»åŠ ',
        icon: 'success'
      })
	  // è®¡ç®—ç®­å¤´ä½ç½®ï¼ˆåœ¨ç»ˆç‚¹å‰ä¸€å°æ®µè·ç¦»ï¼‰
	  const startLat = testLine['points'][0].latitude
	  const startLng = testLine['points'][0].longitude
	  const endLat = testLine['points'][1].latitude
	  const endLng = testLine['points'][1].longitude
	  
	  // è®¡ç®—æ–¹å‘å‘é‡å¹¶åœ¨ç»ˆç‚¹å‰æ”¾ç½®ç®­å¤´
	  const distance = 0.0001 // ç®­å¤´è·ç¦»ç»ˆç‚¹çš„è·ç¦»
	  const bearing = calculateArrowRotation(startLat, startLng, endLat, endLng)
	  const arrowLat = endLat - distance * Math.cos(bearing * Math.PI / 180)
	  const arrowLng = endLng - distance * Math.sin(bearing * Math.PI / 180)
	  
	  // åˆ›å»ºç®­å¤´æ ‡è®°ï¼ˆçœ‹èµ·æ¥åƒçº¿æ¡çš„ä¸€éƒ¨åˆ†ï¼‰
	  const arrowMarker = {
	    id: `arrow_${Date.now()}`,
	    longitude: arrowLng,
	    latitude: arrowLat,
	    iconPath: '/static/icons/arrow.png',
	    width: 16,
	    height: 16,
	    rotate: bearing,
	    anchor: {
	      x: 0.5,
	      y: 0.5
	    }
	  }
	  
	  markers.value.push(arrowMarker)
	  // å¼ºåˆ¶åˆ·æ–°åœ°å›¾æ•°æ®
	  polylines.value = [...polylines.value]
	  markers.value = [...markers.value]
    }

    // ç”Ÿå‘½å‘¨æœŸ
    onMounted(() => {
      // åˆå§‹åŒ–æ•°æ®
      console.log('é‡‡é›†é¡µé¢åˆå§‹åŒ–å®Œæˆ')

      // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
      checkNetworkStatus()

      // æ£€æŸ¥å®šä½æƒé™å¹¶è·å–å½“å‰ä½ç½®
      checkLocationPermission()

      // 5ç§’åæ·»åŠ æµ‹è¯•çº¿æ¡
      setTimeout(() => {
        testPolyline()
      }, 3000)
    })

    // é¡µé¢æ˜¾ç¤ºæ—¶é‡æ–°æ³¨å†Œäº‹ä»¶ç›‘å¬å™¨
    const onShow = () => {
      // å…ˆç§»é™¤ä¹‹å‰çš„ç›‘å¬å™¨ï¼Œé¿å…é‡å¤æ³¨å†Œ
      uni.$off('addPipePoint');
      
      // é‡æ–°ç›‘å¬ç®¡ç‚¹ä¿å­˜äº‹ä»¶
      uni.$on('addPipePoint', (pointData) => {
        console.log('æ¥æ”¶åˆ°æ–°ç®¡ç‚¹æ•°æ®:', pointData);
        console.log('åŸå§‹ç®¡ç‚¹ID:', pointData.id, '(ç±»å‹:', typeof pointData.id, ')');
        
        // ä½¿ç”¨å½“å‰markersæ•°ç»„é•¿åº¦+1ä½œä¸ºå”¯ä¸€IDï¼Œç¡®ä¿ä¸é‡å¤
        const uniqueId = markers.value.length + 1;
        pointData.id = uniqueId;
        pointData.markerId = uniqueId;
        
        console.log('å¤„ç†åçš„ç®¡ç‚¹æ•°æ®:', {
          id: pointData.id,
          markerId: pointData.markerId,
          title: pointData.title
        });
        
        markers.value.push(pointData);
        console.log('æ·»åŠ åçš„markersæ•°ç»„:', markers.value.map(m => ({ 
          id: m.id, 
          markerId: m.markerId,
          title: m.title 
        })));
        
        // è°ƒè¯•ï¼šè¾“å‡ºå®Œæ•´çš„markeræ•°æ®ç»“æ„
        console.log('å®Œæ•´çš„markeræ•°æ®ç»“æ„:');
        markers.value.forEach((marker, index) => {
          console.log(`Marker ${index}:`, JSON.stringify(marker, null, 2));
        });
        
        // å¼ºåˆ¶æ›´æ–°åœ°å›¾ç»„ä»¶
        markers.value = [...markers.value];
        uni.showToast({
          title: 'ç®¡ç‚¹å·²æ·»åŠ åˆ°åœ°å›¾',
          icon: 'success'
        });
      });
    }

    // æ£€æŸ¥ç½‘ç»œçŠ¶æ€
    const checkNetworkStatus = () => {
      uni.getNetworkType({
        success: (res) => {
          console.log('ç½‘ç»œç±»å‹:', res.networkType);
          if (res.networkType === 'none') {
            uni.showToast({
              title: 'ç½‘ç»œè¿æ¥å¼‚å¸¸ï¼Œè¯·æ£€æŸ¥ç½‘ç»œè®¾ç½®',
              icon: 'none',
              duration: 3000
            });
          }
        }
      });
    }

    // è·å–å½“å‰ä½ç½®
    const getCurrentLocation = async () => {
      uni.showLoading({
        title: 'å®šä½ä¸­...'
      });
      
      try {
        const res = await uni.getLocation({
          type: 'gcj02',
          altitude: true,
          geocode: true
        });
        
        console.log('å½“å‰ä½ç½®çš„ç»åº¦ï¼š' + res.longitude);
        console.log('å½“å‰ä½ç½®çš„çº¬åº¦ï¼š' + res.latitude);
        
        // æ›´æ–°åœ°å›¾ä¸­å¿ƒç‚¹åˆ°å½“å‰ä½ç½®
        mapCenter.longitude = res.longitude;
        mapCenter.latitude = res.latitude;
        mapScale.value = 18; // æ”¾å¤§åœ°å›¾
        
        uni.hideLoading();
        uni.showToast({
          title: 'å®šä½æˆåŠŸ',
          icon: 'success'
        });
      } catch (error) {
        uni.hideLoading();
        console.error('è·å–ä½ç½®å¤±è´¥ï¼š', error);
        uni.showToast({
          title: 'å®šä½å¤±è´¥ï¼Œè¯·æ£€æŸ¥å®šä½æƒé™',
          icon: 'none',
          duration: 3000
        });
      }
    }

    // æ£€æŸ¥å®šä½æƒé™å¹¶è·å–å½“å‰ä½ç½®
    const checkLocationPermission = async () => {
      // é¡µé¢åŠ è½½æ—¶è‡ªåŠ¨è·å–ä¸€æ¬¡ä½ç½®
      getCurrentLocation();
    }
    
    // é¡µé¢å¸è½½æ—¶ç§»é™¤äº‹ä»¶ç›‘å¬
    const onUnmounted = () => {
      uni.$off('addPipePoint');
    }

    return {
      // å“åº”å¼æ•°æ®
      searchPointNo,
      currentTool,
      mapType,
      mapScale,
      currentLayerIndex,
      showDropdown,
      selectedLayers,
      materialIndex,
      lineTypeIndex,
      lineMaterialIndex,
      layerOptions,
      mapCenter,
      showPointModal,
      showLineModal,
      showPipePointModal,
      measureResult,
      selectedPipePoint,
      markers,
      polylines,
      polygons,
      tempPoints,
      measurePoints,
      
      // ç®¡çº¿ç›¸å…³æ•°æ®
      pipelineMode,
      selectedPoints,

      // æ–¹æ³•
      toggleDropdown,
      selectLayer,
      selectAll,
      selectNone,
      updateLayerDisplay,
      getDisplayText,
      closeDropdown,
      onSearchInput,
      searchPoint,
      toggleMapType,
      selectTool,
      onMapTap,
      getToolName,
      onPoiTap,
      onCalloutTap,
      onControlTap,
      createPoint,
      handleLineCreation,
      createVirtualLine,
      handleMeasure,
      insertPoint,
      calculateDistance,
      calculateArrowRotation,
      openPipeInfo,
      onMarkerTap,
      onRegionChange,
      closePointModal,
      clearMeasure,
      closeMeasureResult,
      onMapError,
      checkNetworkStatus,
      checkLocationPermission,
      getCurrentLocation,
      handleTapForCreation, // æ·»åŠ æ–°å‡½æ•°åˆ°è¿”å›å¯¹è±¡
      onShow,
      onUnmounted,
      
      // ç®¡çº¿ç›¸å…³æ–¹æ³•
      highlightMarker,
      navigateToPipelineConfig,
      addPipeline,
    }
  },
  
  // é¡µé¢ç”Ÿå‘½å‘¨æœŸ
  onShow() {
    this.onShow()
  }
}
</script>

<style scoped>
@import './collect-styles.css';
</style>